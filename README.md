# Frasty

Цель, лежащая в основе Frasty - это предоставление инфраструктуры для выполнения распределенных и многоэтапных задач.

Существует большое количество платформ и сервисов для автоматизации рабочих процессов. Frasty ни в коем случае не пытается быть еще одним таким сервисом. Его задача - это расширение возможностей и оптимизация затрат при использовании существующих сервисов, а именно:
- Создание полного цикла автоматизации процессов, в которых существующие сервисы автоматизации способны выполнить только часть работы.
- Уменьшение затрат путем переноса части шагов из внешних сервисов и платы только за действительно полезные действия.
- Автоматизация длительных процессов, на определенных этапах которых требуется вмешательство человека.
- Использование нескольких сервисов автоматизации во время работы процесса.
- Отсылка обезличенных данных для обработки внешними сервисами в процессах обработки персональных данных.
- Удобное использование REST API в качестве шагов.
- И многое другое.

## Принцип работы

Frasty использует концепцию доступных для использования действий, каждое из которых выполняет какую-то полезную работу. Это общепринятый подход.

У каждого действия есть определенная функциональность, входные и выходные данные.

Пользователь подключает набор из имеющихся готовых для использования действий, функциональность которых закрывает общие потребности. В случае необходимости разрабатывает собственные наборы действий для закрытия специфических потребностей.

Из действий можно составлять цепочки любой длины (задачи) и запускать на выполнение.

Действия могут располагаться где угодно, Frasty предоставляет инфраструктуру для их подключения и управления.

Особенностью работы является способ регистрации действий, доступных для создания и запуска задач. Frasty не может самостоятельно зарегистрировать действие. Регистрацию инициирует само действие. После запуска действие периодически отсылает информацию о своем состоянии - heartbeat. Frasty обрабатывает эту информацию, что позволяет ему поддерживать актуальный список доступных действий.

Другой важной особенностью является способ коммуникации с действиями - при работе Frasty полагается на использование асинхронных абстракций **запуска действия** и **обработчика действия**.

Использование абстракции в коммуникации позволяет действиям быть полностью независимыми и  располагаться там, где это представляется наиболее удобным, будь то удобство доступа к данным, требования безопасности, производительность или что-то другое.

Стоит также упомянуть, что внутренняя реализация процесса запуска задачи на выполнение также является еще одной задачей, состоящей из двух действий: запуск задачи и запуск определения и по факту ничем не отличается от задач, которые будут создаваться пользователем.

## Инфраструктура для обеспечения коммуникации

В работе Frasty использует асинхронные абстракции **запуска действия** и **обработчика действия**.

Наиболее очевидным вариантом для создания этой абстракции является использование очередей сообщений. В результате есть возможность встраивания Frasty в существующие системы с уже работающими реализациями очередей сообщений, или использования наиболее удобных вариантов сторонних очередей сообщений в каждом конкретном случае.

Очередь сообщений это только один из вариантов. Другим вариантом может быть использование REST API. Для простейших вариантов можно использовать обычные словари.

Frasty имеет собственную реализацию абстракции для использования с RabbitMQ.

## Сервисы
- Получение списка доступных действий.
- Создание задачи.
- Запуск задачи.
- Запуск задачи по расписанию.
- Получение деталей выполняющейся/выполненной задачи.
- Получение результата выполненной задачи.
- Получение списка задач.

## Производительность

Тестирование производилось на конфигурации с процессором Pentium G3240 c 8 GB Ram и установленной Ubuntu Server. Frasty был развернут в нескольких контейнерах Docker - один контейнер для запуска задач, второй контейнер (в двух экземплярах) для работы с жизненным циклом, третий контейнер с доступными для использования действиями, четвертый контейнер для сохранения результатов выполнения. В качестве реализации очереди сообщений использовался Docker контейнер образа RabbitMQ. Для коммуникации контейнеров использовалась созданная с помощью Docker user-defined сеть. В тестировании использовались 10 созданных заранее задач, каждая из которых состояла из 5 действий. Первое действие запрашивало хтмл страницу с локального веб сервера, действия со второго по пятое проводили поэтапный парсинг хтмл данных. Стресс тест запускался на выполнение 10 разных задач по кругу суммарно 100 000 раз. Было установлено ограничение на количество одновременно выполняемых задач не более 200. Директории контейнеров, куда сохранялись результаты работы, были смонтированы на директорию жесткого диска.

Frasty смог выполнить **более 50 000 задач** в течении часа, или **более 1 200 000 задач** в сутки.

Проблем с блокировками или неверными/испорченными данными выявлено не было.

## Текущий статус

Сейчас идет активная работа по изменению проекта для соответствия его описанным целям.

В данный момент существует серьезный недостаток в виде необходимости дополнительно создавать спецификацию для каждого действия в виде отдельного класса и явно добавлять эту спецификацию при запуске обработчика жизненного цикла, чтобы была возможность использовать действие. Ведется работа над устранением этого недостатка и созданием логики для саморегистрации действия в момент подключения.

Также есть недостаток в виде необходимости определять четыре дополнительных асинхронных абстракции для запуска задачи, запуска определения, завершения действия и публикации завершенной обработки. Эти абстракции являются избыточными и в ближайшее время они будут полностью исключены из проекта.

## Немного истории

Frasty начинался как пет проект для создания задач по обнаружению обновлений данных на веб страницах и доставки этой информации в мессенджеры. Удобнее всего это было реализовать в виде конвейера обработки, состоящего из шагов-обработчиков, получавших данные на вход и передававших выходные данные на вход следующего шага. Одним из требований была возможность запускать задачи по расписанию. Проект был реализован в виде распределенного монолита с довольно запутанной структурой. В качестве очереди сообщений использовалась реализация RabbitMQ. Для полного удовлетворения потребностей оказалось достаточно разработать несколько универсальных обработчиков.

После проект был полностью переработан на микросервисную архитектуру, и обрел простую и понятную структуру. Однако для каждого нового обработчика необходимо было вносить изменения в проект для возможности корректного подключения этих новых обработчиков. Также была в наличии жесткая связь с брокером сообщений RabbitMQ по всей структуре проекта. Появилась идея о реализации саморегистрирующихся обработчиков, что тем самым должно было значительно упростить процесс добавления новых видов обработчиков. Также желательна была возможность использовать различные реализации очереди сообщений и не быть жестко привязанным к RabbitMQ.

На следующей итерации был проведен рефакторинг, целью которого было убрать жесткую зависимость от RabbitMQ. Вся конфигурация RabbitMQ была вынесена на границу проекта в инфраструктуру.

Последующим этапом стало создание абстракции для инфраструктуры очереди сообщений. Было веделено 6 абстракций, которые полностью закрыли потребности жизненного цикла. Была создана реализация абстракции для RabbitMQ. Во время анализа результатов этапа было сделано предположение что 5 из 6 абстракций являются избыточными. Была предпринята успешная попытка удаления абстракции работы с расписанием запусков. Удаление оставшихся избыточных абстракций запуска задачи, запуска определения, завершения действия и публикации завершенной обработки было запланировано к реализации после этапа создания логики саморегистрирующих действий.

